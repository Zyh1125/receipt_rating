import FeedSchema from '../models/feed';
import ProductSchema from '../models/product';
import ProfileSchema from '../models/profile';
import ReceiptSchema from '../models/receipt';
import { createAltNovaGroup, createAltNutriScore } from './recommenderService';
import Userschema from '../models/user';
import { IFeedItem } from '../models/types';

/* Triggers recommendation generation, aggregates all feed items and stores them into the db */
export const generateFeed = async (userID:string) => {
    const result = await FeedSchema.findOne({ userID: userID })
    if (result == null) {
        // create empty feed object in database
        FeedSchema.create(
            {
                userID: userID,
                feed: [],
                bookmarks: [],
                ratings: []
            }
        )
    }

    // get receipts
    const receipts = await ReceiptSchema.find({userID: userID})

    // get products from user's receipts
    let promises:any = []
    receipts.forEach(async (receipt: any) => {
        // get product information
        receipt.products.forEach(async (product: any) => {
            if (product.product != "") {
                promises.push(ProductSchema.findById(product.product))
            }
        })
    })
    let product_list = await Promise.all(promises) // all products to be analyzed by recommender services

    // get user profile
    const profile = await ProfileSchema.findOne({ userID: userID })

    // get user ratings
    const ratings = (await FeedSchema.findOne({ userID: userID }))?.ratings // ratings including the feed item
    const feedItem_ids_ignore = ratings.map((rating:any) => {return rating.feedItem.uid}) // only uids of feed items to be ignored based on ratings
    const product_ids_ignore = ratings.map((rating:any) => {
        if (rating.ratingInfo.ignoreProduct) {
            return rating.feedItem.parameters.product.ean
        }
    }) // eans of products to be ignored
    const ratings_amt = ratings.length

    // remove products to be ignored
    product_list = product_list.filter((product) => {
        if (!product_ids_ignore.includes(product.ean)) {
            return product
        }
    })

    // categories to be ignored
    const ignore_categories = ratings.map((rating:any) => {
        if (rating.ratingInfo.ignoreCategory == true) {
            return rating.feedItem.category
        }
    })

    let p = []
    //@ts-ignore
    if (profile?.feed_categories.altNutriScore) {
        p.push(createAltNutriScore(product_list, profile.tags, ignore_categories))
    }
    //@ts-ignore
    if (profile?.feed_categories.altNovaGroup) {
        p.push(createAltNovaGroup(product_list, profile.tags, ignore_categories))
    }
    let results = await Promise.all(p)
    const results1:any = results[0] ? results[0] : []
    const results2:any = results[1] ? results[1] : []

    let r = results1.concat(results2) 
    r = r.flat()
    //r = r.slice(0,100) // max 100 items in feed

    r = filterRatings(r, feedItem_ids_ignore)

    console.log(r.length+" items generated")

    // reset all feed items
    await resetFeedItems(userID)

    // push all items to database
    //@ts-ignore
    r.map(async (item) => {
        await FeedSchema.updateOne({userID: userID}, { $push: { feed: item }})
    })

    // log feed generation date, amount of products, amount of generated alternatives and profile settings
    const date = new Date() // timestamp of feed generation triggered by the user
    const amount_products = product_list.length // amount of all products except ignored and rated ones -> products usable for recommender service
    const amount_alternatives = r.length // amount of alternatives generated by recommender service

    const profile_settings = {tags: profile?.tags, feed_categories: profile?.feed_categories} // current profile settings at the time of feed generation

    const stats:any = {
        date: date,
        amount_products: amount_products,
        amount_alternatives: amount_alternatives,
        profile_settings: profile_settings
    }
    let user = await Userschema.findById(userID)
    if (user) {
        user.feedStats = user.feedStats
            ? user.feedStats.concat(stats)
            : [stats]

        await Userschema.findByIdAndUpdate(userID, user)
    }
}
export const resetFeedItems = async (userID: string) => {
    await FeedSchema.findOneAndUpdate({ userID: userID }, { feed: [] })
}

/* Filters out all feed items that have already been negatively rated */
const filterRatings = (feed: IFeedItem[], ratings:any) => {
    return feed.filter((item) => {
        if (ratings?.includes(item.uid)) {
            console.log("filtered out "+item.uid)
        }
        return !ratings.includes(item.uid)
    })
}